// controllers/userController.js

const User = require('../models/User');
const { Op } = require('sequelize');

const { sendRegistrationEmail } = require('../services/emailService');

// Helper function to generate secure password
const generateSecurePassword = (length = 12) => {
  const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
  let password = "";
  for (let i = 0; i < length; i++) {
    password += charset.charAt(Math.floor(Math.random() * charset.length));
  }
  return password;
};

// Helper function to generate unique username
const generateUniqueUsername = async (baseName) => {
  const baseUsername = (baseName || 'user').toLowerCase().replace(/\s+/g, '');
  let username = baseUsername;
  let counter = 1;
  
  // Keep trying until we find a unique username
  while (await User.findOne({ where: { username } })) {
    username = `${baseUsername}${counter}`;
    counter++;
  }
  
  return username;
};

// Create User
exports.createUser = async (req, res) => {
  try {
    const { 
      smartuseremail, 
      smartusername, 
      smartuserphone, 
      smartuserrank,
      userId,
      roleId,
      roleName,
      stations 
    } = req.body;

    // Validation: At least email or phone should be provided
    if (!smartuseremail && !smartuserphone) {
      return res.status(400).json({ 
        message: 'Either email or phone number is required for registration.' 
      });
    }

    // Check if smart user email already exists
    if (smartuseremail) {
      const existingSmartEmail = await User.findOne({ where: { smartuseremail } });
      if (existingSmartEmail) {
        return res.status(400).json({ 
          message: 'This email address is already registered. Please use a different email.' 
        });
      }
    }

    // Check if smart user phone already exists
    if (smartuserphone) {
      const existingSmartPhone = await User.findOne({ where: { smartuserphone } });
      if (existingSmartPhone) {
        return res.status(400).json({ 
          message: 'This phone number is already registered. Please use a different phone number.' 
        });
      }
    }

    // Generate unique username and secure password
    const username = await generateUniqueUsername(smartusername);
    const password = generateSecurePassword();

    // Store the plain password temporarily for email
    const plainPassword = password;

    const newUser = await User.create({ 
      roleId: roleId || null, 
      roleName: roleName || null,
      smartuseremail: smartuseremail || null,
      smartusername: smartusername || null,
      smartuserphone: smartuserphone || null,
      smartuserrank: smartuserrank || null,
      stations: stations || [],
      userId: userId || null,
      username, 
      password,
      autoGeneratedPassword: plainPassword, // Store for reference
      isFirstLogin: true
    });

    // Send registration email with credentials (only if email is provided)
    let emailResult = { success: true };
    if (smartuseremail) {
      emailResult = await sendRegistrationEmail(smartuseremail, {
        name: smartusername || 'User',
        username,
        password: plainPassword
      });

      if (!emailResult.success) {
        console.error('Failed to send registration email:', emailResult.error);
        // Consider if you want to rollback user creation or just log the error
      }
    }

    res.status(201).json({ 
      message: 'User created successfully',
      data: {
        id: newUser.id,
        username: newUser.username,
        smartuseremail: newUser.smartuseremail,
        smartusername: newUser.smartusername,
        smartuserphone: newUser.smartuserphone,
        roleName: newUser.roleName,
        emailSent: emailResult.success
      }
    });
  } catch (err) {
    console.error('Error creating user:', err);
    res.status(500).json({ 
      message: 'Error creating user', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};

// Get All Users
exports.getUsers = async (req, res) => {
  try {
    const { page = 1, limit = 10, search, roleId, roleName } = req.query;
    
    const whereClause = {};
    
    // Add search functionality
    if (search) {
      whereClause[Op.or] = [
        { smartusername: { [Op.iLike]: `%${search}%` } },
        { smartuseremail: { [Op.iLike]: `%${search}%` } },
        { smartuserphone: { [Op.like]: `%${search}%` } }
      ];
    }
    
    // Filter by role
    if (roleId) whereClause.roleId = roleId;
    if (roleName) whereClause.roleName = roleName;

    const offset = (page - 1) * limit;
    
    const { count, rows: users } = await User.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [['createdAt', 'DESC']],
      attributes: { exclude: ['password', 'autoGeneratedPassword'] } // Don't send passwords
    });

    res.status(200).json({
      users,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / limit),
        totalUsers: count,
        hasNext: offset + users.length < count,
        hasPrev: page > 1
      }
    });
  } catch (err) {
    console.error('Error fetching users:', err);
    res.status(500).json({ 
      message: 'Error fetching users', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};

// Get User by ID
exports.getUserById = async (req, res) => {
  try {
    const user = await User.findByPk(req.params.id, {
      attributes: { exclude: ['password', 'autoGeneratedPassword'] }
    });
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    res.status(200).json(user);
  } catch (err) {
    console.error('Error fetching user:', err);
    res.status(500).json({ 
      message: 'Error fetching user', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};

// Update User
exports.updateUser = async (req, res) => {
  try {
    const { 
      roleId, 
      roleName,
      smartuseremail,
      smartusername,
      smartuserphone,
      smartuserrank,
      stations,
      userId
    } = req.body;

    const user = await User.findByPk(req.params.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check if smart user email already exists (excluding current user)
    if (smartuseremail && smartuseremail !== user.smartuseremail) {
      const existingSmartEmail = await User.findOne({ 
        where: { 
          smartuseremail,
          id: { [Op.ne]: req.params.id } // Exclude current user
        } 
      });
      if (existingSmartEmail) {
        return res.status(400).json({ 
          message: 'This email address is already registered. Please use a different email.' 
        });
      }
    }

    // Check if smart user phone already exists (excluding current user)
    if (smartuserphone && smartuserphone !== user.smartuserphone) {
      const existingSmartPhone = await User.findOne({ 
        where: { 
          smartuserphone,
          id: { [Op.ne]: req.params.id } // Exclude current user
        } 
      });
      if (existingSmartPhone) {
        return res.status(400).json({ 
          message: 'This phone number is already registered. Please use a different phone number.' 
        });
      }
    }

    // Generate new username if smartusername is changed
    let username = user.username;
    
    if (smartusername && smartusername !== user.smartusername) {
      username = await generateUniqueUsername(smartusername);
    }

    // Update fields only if they are provided
    const updateData = {};
    if (roleId !== undefined) updateData.roleId = roleId;
    if (roleName !== undefined) updateData.roleName = roleName;
    if (smartuseremail !== undefined) updateData.smartuseremail = smartuseremail;
    if (smartusername !== undefined) updateData.smartusername = smartusername;
    if (smartuserphone !== undefined) updateData.smartuserphone = smartuserphone;
    if (smartuserrank !== undefined) updateData.smartuserrank = smartuserrank;
    if (stations !== undefined) updateData.stations = stations;
    if (userId !== undefined) updateData.userId = userId;
    if (username !== user.username) updateData.username = username;

    await user.update(updateData);

    res.status(200).json({ 
      message: 'User updated successfully',
      data: {
        id: user.id,
        username: user.username,
        smartuseremail: user.smartuseremail,
        smartusername: user.smartusername,
        smartuserphone: user.smartuserphone,
        roleName: user.roleName
      }
    });
  } catch (err) {
    console.error('Error updating user:', err);
    res.status(500).json({ 
      message: 'Error updating user', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};

// Delete User
exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findByPk(req.params.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    await user.destroy();

    res.status(200).json({ message: 'User deleted successfully' });
  } catch (err) {
    console.error('Error deleting user:', err);
    res.status(500).json({ 
      message: 'Error deleting user', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};

// Reset Password (New endpoint for admin to reset user password)
exports.resetUserPassword = async (req, res) => {
  try {
    const user = await User.findByPk(req.params.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    const newPassword = generateSecurePassword();
    
    await user.update({
      password: newPassword,
      autoGeneratedPassword: newPassword,
      isFirstLogin: true
    });

    // Send email with new password if email exists
    let emailResult = { success: true };
    if (user.smartuseremail) {
      emailResult = await sendRegistrationEmail(user.smartuseremail, {
        name: user.smartusername || 'User',
        username: user.username,
        password: newPassword,
        isReset: true
      });
    }

    res.status(200).json({ 
      message: 'Password reset successfully',
      emailSent: emailResult.success
    });
  } catch (err) {
    console.error('Error resetting password:', err);
    res.status(500).json({ 
      message: 'Error resetting password', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};



exports.getUsersByStation = async (req, res) => {
  try {
    // 🔥 FIX: Set no-cache headers to prevent 304 Not Modified responses
    res.set({
      'Cache-Control': 'no-cache, no-store, must-revalidate, private',
      'Pragma': 'no-cache',
      'Expires': '0',
      'Last-Modified': new Date().toUTCString(),
      'ETag': `"${Date.now()}"` // Dynamic ETag to force fresh requests
    });

    const { stationId } = req.params;
    const { page = 1, limit = 10, search, roleId, roleName } = req.query;
    
    if (!stationId) {
      return res.status(400).json({ 
        message: 'Station ID is required' 
      });
    }

    const offset = (page - 1) * limit;
    
    // Build base WHERE clause using raw SQL for JSON operations
    let whereConditions = [`stations::text LIKE '%"id":${parseInt(stationId)}%'`];
    let replacements = {};
    
    // Add search functionality
    if (search) {
      whereConditions.push(`(
        "smartusername" ILIKE :search OR 
        "smartuseremail" ILIKE :search OR 
        "smartuserphone" LIKE :search OR 
        "smartuserrank" ILIKE :search
      )`);
      replacements.search = `%${search}%`;
    }
    
    // Filter by role
    if (roleId) {
      whereConditions.push(`"roleId" = :roleId`);
      replacements.roleId = roleId;
    }
    
    if (roleName) {
      whereConditions.push(`"roleName" = :roleName`);
      replacements.roleName = roleName;
    }
    
    const whereClause = whereConditions.join(' AND ');
    
    // Get total count
    const countQuery = `
      SELECT COUNT(*) as count 
      FROM "Users" 
      WHERE ${whereClause}
    `;
    
    const countResult = await User.sequelize.query(countQuery, {
      replacements,
      type: User.sequelize.QueryTypes.SELECT
    });
    
    const totalCount = parseInt(countResult[0].count);
    
    // Get users with pagination
    const usersQuery = `
      SELECT "id", "smartuseremail", "smartusername", "smartuserphone", "smartuserrank", 
             "userId", "roleId", "roleName", "stations", "username", "createdAt", "updatedAt"
      FROM "Users" 
      WHERE ${whereClause}
      ORDER BY "createdAt" DESC 
      LIMIT :limit OFFSET :offset
    `;
    
    const users = await User.sequelize.query(usersQuery, {
      replacements: { ...replacements, limit: parseInt(limit), offset: parseInt(offset) },
      type: User.sequelize.QueryTypes.SELECT
    });

    // Get station name from the first user's stations
    let stationName = null;
    if (users.length > 0 && users[0].stations) {
      try {
        const stations = typeof users[0].stations === 'string' 
          ? JSON.parse(users[0].stations) 
          : users[0].stations;
        
        if (Array.isArray(stations)) {
          const station = stations.find(s => s.id === parseInt(stationId));
          stationName = station ? station.name : null;
        }
      } catch (e) {
        console.error('Error parsing stations:', e);
      }
    }

    // Debug logging to verify fresh data is being sent
    console.log(`📡 Fresh data sent for station ${stationId} - ${users.length} users found at ${new Date().toISOString()}`);

    res.status(200).json({
      message: 'Users fetched successfully',
      data: {
        users,
        stationInfo: {
          stationId: parseInt(stationId),
          stationName: stationName
        },
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalCount / limit),
          totalUsers: totalCount,
          hasNext: offset + users.length < totalCount,
          hasPrev: page > 1
        },
        // Add timestamp to verify fresh data
        fetchedAt: new Date().toISOString()
      }
    });
  } catch (err) {
    console.error('Error fetching users by station:', err);
    res.status(500).json({ 
      message: 'Error fetching users by station', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
    });
  }
};
